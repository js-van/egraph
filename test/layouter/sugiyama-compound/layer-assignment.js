/* eslint-env mocha */
const assert = require('power-assert')
const Graph = require('../../../graph')
const derivedGraph = require('../../../layouter/sugiyama-compound/derived-graph')
const acyclicDerivedGraph = require('../../../layouter/sugiyama-compound/acyclic-derived-graph')
const layerAssignment = require('../../../layouter/sugiyama-compound/layer-assignment')
const normalize = require('../../../layouter/sugiyama-compound/normalize')

describe('derivedGraph(graph)', () => {
  it('', () => {
    const [a, b, c, d, e, f, g, h, i, j, k, l, m, n] = 'abcdefghijklmn'
    const graph = new Graph()
      .addVertex(a)
      .addVertex(b)
      .addVertex(c)
      .addVertex(d)
      .addVertex(e)
      .addVertex(f)
      .addVertex(g)
      .addVertex(h)
      .addVertex(i)
      .addVertex(j)
      .addVertex(k)
      .addVertex(l)
      .addVertex(m)
      .addVertex(n)
      .addEdge(b, c)
      .addEdge(d, e)
      .addEdge(g, b)
      .addEdge(h, m)
      .addEdge(i, n)
      .addEdge(j, l)
      .addEdge(k, l)
      .addEdge(m, i)
      .addEdge(m, n)
      .setChild(a, b)
      .setChild(a, c)
      .setChild(b, d)
      .setChild(b, e)
      .setChild(b, f)
      .setChild(e, j)
      .setChild(f, k)
      .setChild(f, l)
      .setChild(c, g)
      .setChild(c, h)
      .setChild(c, i)
      .setChild(g, m)
      .setChild(g, n)
    const derived = derivedGraph(graph)
    assert.equal(derived.edge(c, b).priority, -1)
    assert.equal(derived.edge(e, f).priority, -2)
    assert.equal(derived.edge(g, i).priority, -1)
    assert.equal(derived.edge(h, g).priority, -1)
    assert.equal(derived.edge(i, g).priority, -1)
  })
})

describe('acyclicDerivedGraph(graph)', () => {
  it('', () => {
    const [a, b, c, d, e, f, g, h, i, j, k, l, m, n] = 'abcdefghijklmn'
    const graph = new Graph()
      .addVertex(a)
      .addVertex(b)
      .addVertex(c)
      .addVertex(d)
      .addVertex(e)
      .addVertex(f)
      .addVertex(g)
      .addVertex(h)
      .addVertex(i)
      .addVertex(j)
      .addVertex(k)
      .addVertex(l)
      .addVertex(m)
      .addVertex(n)
      .addEdge(b, c)
      .addEdge(c, b, {priority: -1})
      .addEdge(d, e)
      .addEdge(e, f, {priority: -2})
      .addEdge(g, b)
      .addEdge(g, i, {priority: -1})
      .addEdge(h, g, {priority: -1})
      .addEdge(h, m)
      .addEdge(i, g, {priority: -1})
      .addEdge(i, n)
      .addEdge(j, l)
      .addEdge(k, l)
      .addEdge(m, i)
      .addEdge(m, n)
      .setChild(a, b)
      .setChild(a, c)
      .setChild(b, d)
      .setChild(b, e)
      .setChild(b, f)
      .setChild(e, j)
      .setChild(f, k)
      .setChild(f, l)
      .setChild(c, g)
      .setChild(c, h)
      .setChild(c, i)
      .setChild(g, m)
      .setChild(g, n)
    acyclicDerivedGraph(graph)
    assert(!graph.edge(c, b))
    assert(!graph.edge(g, i))
    assert(graph.edge(b, c))
    assert(graph.edge(i, g))
  })
})

describe('layerAssignment(graph)', () => {
  it('', () => {
    const [a, b, c, d, e, f, g, h, i, j, k, l, m, n] = 'abcdefghijklmn'
    const graph = new Graph()
      .addVertex(a)
      .addVertex(b)
      .addVertex(c)
      .addVertex(d)
      .addVertex(e)
      .addVertex(f)
      .addVertex(g)
      .addVertex(h)
      .addVertex(i)
      .addVertex(j)
      .addVertex(k)
      .addVertex(l)
      .addVertex(m)
      .addVertex(n)
      .addEdge(b, c)
      .addEdge(d, e)
      .addEdge(e, f, {priority: -2})
      .addEdge(g, b)
      .addEdge(g, i)
      .addEdge(h, g)
      .addEdge(h, m)
      .addEdge(i, n)
      .addEdge(j, l)
      .addEdge(k, l)
      .addEdge(m, i)
      .addEdge(m, n)
      .setChild(a, b)
      .setChild(a, c)
      .setChild(b, d)
      .setChild(b, e)
      .setChild(b, f)
      .setChild(e, j)
      .setChild(f, k)
      .setChild(f, l)
      .setChild(c, g)
      .setChild(c, h)
      .setChild(c, i)
      .setChild(g, m)
      .setChild(g, n)
    layerAssignment(graph)
    assert.deepEqual(graph.vertex(a).layer, [0])
    assert.deepEqual(graph.vertex(b).layer, [0, 0])
    assert.deepEqual(graph.vertex(c).layer, [0, 1])
    assert.deepEqual(graph.vertex(d).layer, [0, 0, 0])
    assert.deepEqual(graph.vertex(e).layer, [0, 0, 1])
    assert.deepEqual(graph.vertex(f).layer, [0, 0, 1])
    assert.deepEqual(graph.vertex(g).layer, [0, 1, 1])
    assert.deepEqual(graph.vertex(h).layer, [0, 1, 0])
    assert.deepEqual(graph.vertex(i).layer, [0, 1, 2])
    assert.deepEqual(graph.vertex(j).layer, [0, 0, 1, 0])
    assert.deepEqual(graph.vertex(k).layer, [0, 0, 1, 0])
    assert.deepEqual(graph.vertex(l).layer, [0, 0, 1, 1])
    assert.deepEqual(graph.vertex(m).layer, [0, 1, 1, 0])
    assert.deepEqual(graph.vertex(n).layer, [0, 1, 1, 1])
  })
})

describe('normalize(graph, layers)', () => {
  it('', () => {
    const [a, b, c, d, e, f, g, h, i, j, k, l, m, n] = 'abcdefghijklmn'
    const graph = new Graph()
      .addVertex(a, {layer: [0]})
      .addVertex(b, {layer: [0, 0]})
      .addVertex(c, {layer: [0, 1]})
      .addVertex(d, {layer: [0, 0, 0]})
      .addVertex(e, {layer: [0, 0, 1]})
      .addVertex(f, {layer: [0, 0, 1]})
      .addVertex(g, {layer: [0, 1, 1]})
      .addVertex(h, {layer: [0, 1, 0]})
      .addVertex(i, {layer: [0, 1, 2]})
      .addVertex(j, {layer: [0, 0, 1, 0]})
      .addVertex(k, {layer: [0, 0, 1, 0]})
      .addVertex(l, {layer: [0, 0, 1, 1]})
      .addVertex(m, {layer: [0, 1, 1, 0]})
      .addVertex(n, {layer: [0, 1, 1, 1]})
      .addEdge(b, c)
      .addEdge(b, g)
      .addEdge(d, e)
      .addEdge(h, m)
      .addEdge(j, l)
      .addEdge(k, l)
      .addEdge(m, n)
      .addEdge(m, i)
      .addEdge(n, i)
      .setChild(a, b)
      .setChild(a, c)
      .setChild(b, d)
      .setChild(b, e)
      .setChild(b, f)
      .setChild(e, j)
      .setChild(f, k)
      .setChild(f, l)
      .setChild(c, g)
      .setChild(c, h)
      .setChild(c, i)
      .setChild(g, m)
      .setChild(g, n)
    normalize(graph)
    assert.equal(graph.numVertices(), 22)
    assert.equal(graph.numEdges(), 13)
  })
})
